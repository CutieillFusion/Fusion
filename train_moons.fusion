# Make-moons dataset: two interleaving semicircles (class 0 and class 1).
# Like sklearn.datasets.make_moons: points on two arcs in 2D.
#
# Moon 0 (class 0): upper semicircle  x = cos(t), y = sin(t),  t in [0, pi]
# Moon 1 (class 1): shifted semicircle x = 1 - cos(t), y = 1 - sin(t) - 0.5
# Angles t evenly spaced. Gaussian noise (sigma) added via Box-Muller from rand().

struct Point { x: f64; y: f64; class: f64; };

struct Value {
  data: f64;
  grad: f64;
  prev: ptr;
  op: i64;
};

extern lib "libm.so.6" {
  fn cos(x: f64) -> f64;
  fn sin(x: f64) -> f64;
  fn log(x: f64) -> f64;
  fn sqrt(x: f64) -> f64;
};

extern lib "libc.so.6" {  
  fn rand() -> i32;
};

fn rand_uniform_neg1_1() -> f64 {
  # Returns a random f64 in [-1, 1] using libc rand()
  let r = rand() as f64;
  return 2.0 * (r / 2147483647.0) - 1.0;
}


fn add_forward(a: ptr, b: ptr) -> ptr {
  let out = alloc(Value);
  store_field(out, Value, data, load_field(a, Value, data) + load_field(b, Value, data));
  store_field(out, Value, grad, load_field(a, Value, grad) + load_field(b, Value, grad));
  let prev = alloc_array(ptr, 2);
  prev[0] = a;
  prev[1] = b;
  store_field(out, Value, prev, prev);
  store_field(out, Value, op, 0);
  return out;
}

fn add_backward(out: ptr) -> void {
  let prev = load_field(out, Value, prev);
  let a = prev[0] as ptr;
  let b = prev[1] as ptr;
  store_field(a, Value, grad, load_field(a, Value, grad) + load_field(out, Value, grad));
  store_field(b, Value, grad, load_field(b, Value, grad) + load_field(out, Value, grad));
}

fn mul_forward(a: ptr, b: ptr) -> ptr {
  let out = alloc(Value);
  store_field(out, Value, data, load_field(a, Value, data) * load_field(b, Value, data));
  store_field(out, Value, grad, load_field(a, Value, grad) * load_field(b, Value, grad));
  let prev = alloc_array(ptr, 2);
  prev[0] = a;
  prev[1] = b;
  store_field(out, Value, prev, prev);
  store_field(out, Value, op, 1);
  return out;
}

fn mul_backward(out: ptr) -> void {
  let prev = load_field(out, Value, prev);
  let a = prev[0] as ptr;
  let b = prev[1] as ptr;
  store_field(a, Value, grad, load_field(b, Value, data) * load_field(out, Value, grad));
  store_field(b, Value, grad, load_field(a, Value, data) * load_field(out, Value, grad));
}

fn relu_forward(x: ptr) -> ptr {
  let out = alloc(Value);
  let v = 0.0;
  if (load_field(x, Value, data) > 0.0) {
    v = load_field(x, Value, data);
  }
  store_field(out, Value, data, v);
  let prev = alloc_array(ptr, 1);
  prev[0] = x;
  store_field(out, Value, prev, prev);
  store_field(out, Value, op, 2);
  return out;
}

fn relu_backward(out: ptr) -> void {
  let prev = load_field(out, Value, prev);
  let x = prev[0] as ptr;
  let v = 0.0;
  if (load_field(out, Value, data) > 0.0) {
    v = 1.0;
  }
  store_field(x, Value, grad, v * load_field(out, Value, grad));
}

fn build_topo(root: ptr, visited: ptr, visited_count: i64, topo: ptr, topo_count: i64) -> i64 {
  let mut_count = topo_count;
  for i in range(visited_count, i64) {
    let v = visited[i] as ptr;
    if (v != root) {
      visited[visited_count] = v;
      let children = load_field(v, Value, prev);
      let op = load_field(v, Value, op);
      let num_children = 2;
      if (op == 2) {
        num_children = 1;
      }
      for j in range(num_children, i64) {
        let child = children[j] as ptr;
        mut_count = build_topo(child, visited, visited_count + 1, topo, mut_count);
      }
    }
    topo[mut_count] = v;
    mut_count = mut_count + 1;
  }
  return mut_count;
}

fn backward(root: ptr) -> void {
  let children_count = 1000;
  let topo = alloc_array(ptr, children_count);
  let visited = alloc_array(ptr, children_count);

  let total_topo_count = build_topo(root, visited, 0, topo, 0);

  let reverse_topo = alloc_array(ptr, total_topo_count);
  for i in range(total_topo_count, i64) {
    reverse_topo[i] = topo[total_topo_count - i];
  }

  for i in range(total_topo_count, i64) {
    let v = reverse_topo[i] as ptr;
    let children = load_field(v, Value, prev);
    let op = load_field(v, Value, op);
    let num_children = 2;
    if (op == 2) {
      num_children = 1;
    }
    for j in range(num_children, i64) {
      let child = children[j] as ptr;
      let child_op = load_field(child, Value, op);
      if (child_op == 0) {
        add_backward(child);
      } else if (child_op == 1) {
        mul_backward(child);
      } else if (child_op == 2) {
        relu_backward(child);
      }
    }
  }
}

let n = 200;
let pi = 3.14159265358979;
let sigma = 0.1;
let rand_max = 2147483647.0;

# Arrays of pointers to Point (one per moon)
let moons = alloc_array(ptr, n * 2);

# Moon 0: upper semicircle + N(0, sigma^2) noise
for i in range(n, f64) {
  let t1 = pi * i / ((n - 1) as f64);
  let x0 = cos(t1);
  let y0 = sin(t1);
  let r1_0 = rand() as f64;
  let r2_0 = rand() as f64;
  let u1_0 = (r1_0 + 1.0) / (rand_max + 1.0);
  let u2_0 = (r2_0 + 1.0) / (rand_max + 1.0);
  let z1_0 = sqrt((0.0 - 2.0) * log(u1_0)) * cos(2.0 * pi * u2_0);
  let z2_0 = sqrt((0.0 - 2.0) * log(u1_0)) * sin(2.0 * pi * u2_0);
  let x0_n = x0 + sigma * z1_0;
  let y0_n = y0 + sigma * z2_0;
  let p1 = alloc(Point);
  store_field(p1, Point, x, x0_n);
  store_field(p1, Point, y, y0_n);
  store_field(p1, Point, class, 0.0 - 1.0);
  moons[i as i64] = p1;
}

# Moon 1: shifted semicircle (nests with moon 0) + N(0, sigma^2) noise
for i in range(n, f64) {
  let t2 = pi * i / ((n - 1) as f64);
  let x1 = 1.0 - cos(t2);
  let y1 = 1.0 - sin(t2) - 0.5;
  let r1_1 = rand() as f64;
  let r2_1 = rand() as f64;
  let u1_1 = (r1_1 + 1.0) / (rand_max + 1.0);
  let u2_1 = (r2_1 + 1.0) / (rand_max + 1.0);
  let z1_1 = sqrt((0.0 - 2.0) * log(u1_1)) * cos(2.0 * pi * u2_1);
  let z2_1 = sqrt((0.0 - 2.0) * log(u1_1)) * sin(2.0 * pi * u2_1);
  let x1_n = x1 + sigma * z1_1;
  let y1_n = y1 + sigma * z2_1;
  let p2 = alloc(Point);
  store_field(p2, Point, x, x1_n);
  store_field(p2, Point, y, y1_n);
  store_field(p2, Point, class, 1.0);
  moons[n + i as i64] = p2;
}

let input_size = 2;
let hidden_size = 16;
let output_size = 1;

let W1 = alloc_array(ptr, input_size * hidden_size);
let W2 = alloc_array(ptr, hidden_size * output_size);
let b1 = alloc_array(ptr, hidden_size);
let b2 = alloc_array(ptr, output_size);

for i in range(input_size, i64) {
  for j in range(hidden_size, i64) {
    W1[i * hidden_size + j] = alloc(Value);
    store_field(W1[i * hidden_size + j], Value, data, rand_uniform_neg1_1());
  }
}

for i in range(hidden_size, i64) {
  for j in range(output_size, i64) {
    W2[i * output_size + j] = alloc(Value);
    store_field(W2[i * output_size + j], Value, data, rand_uniform_neg1_1());
  }
}

for i in range(hidden_size, i64) {
  b1[i] = alloc(Value);
  store_field(b1[i], Value, data, 0.0);
}

for i in range(output_size, i64) {
  b2[i] = alloc(Value);
  store_field(b2[i], Value, data, 0.0);
}

let X = alloc_array(ptr, input_size);
let y = alloc_array(ptr, output_size);

let x_0 = alloc(Value);
let y_0 = alloc(Value);
let class_0 = alloc(Value);
store_field(x_0, Value, data, load_field(moons[0], Point, x));
store_field(y_0, Value, data, load_field(moons[0], Point, y));
store_field(class_0, Value, data, load_field(moons[0], Point, class) as f64);

X[0] = x_0;
X[1] = y_0;
y[0] = class_0;

let h1 = alloc_array(ptr, input_size * hidden_size);

for i in range(input_size, i64) {
  for j in range(hidden_size, i64) {
    let h1_mat_mul = mul_forward(X[i], W1[i * hidden_size + j]);
    let h1_add = add_forward(h1_mat_mul, b1[j]);
    let h1_relu = relu_forward(h1_add);
    h1[i * hidden_size + j] = h1_relu;
  }
}

let h2 = alloc_array(ptr, hidden_size * output_size);

for i in range(hidden_size, i64) {
  for j in range(output_size, i64) {
    let h2_mat_mul = mul_forward(h1[i], W2[i * output_size + j]);
    let h2_add = add_forward(h2_mat_mul, b2[j]);
    let h2_relu = relu_forward(h2_add);
    h2[i * output_size + j] = h2_relu;
  }
}

print("X:");
for i in range(input_size, i64) {
  print(load_field(X[i], Value, data));
}

print("h1:");
for i in range(hidden_size, i64) {
  print(load_field(h1[i], Value, data));
}

print("h2:");
for i in range(output_size, i64) {
  print(load_field(h2[i], Value, data));
}

let losses = alloc_array(ptr, output_size);

for i in range(output_size, i64) {
  losses[i] = alloc(Value);
  let pred = load_field(h2[i], Value, data);
  let target = load_field(y[i], Value, data);
  print("pred:");
  print(pred);
  print("target:");
  print(target);
  let loss_value = alloc(Value);
  store_field(loss_value, Value, data, 1.0 - (pred * target));
  let relu_loss = relu_forward(loss_value);
  store_field(losses[i], Value, data, load_field(relu_loss, Value, data));
}

print("losses:");
for i in range(output_size, i64) {
  print(load_field(losses[i], Value, data));
}

let loss = alloc(Value);
store_field(loss, Value, data, 0.0);
for loss_item in losses {
  loss = add_forward(loss, loss_item);
}
print("loss:");
print(load_field(loss, Value, data));

backward(loss);

let learning_rate = 1.0 - 0.9 / 100.0;

for i in range(input_size, i64) {
  for j in range(hidden_size, i64) {
    let w1_grad = load_field(W1[i * hidden_size + j], Value, grad);
    let w1_data = load_field(W1[i * hidden_size + j], Value, data);
    let w1_new_data = w1_data - learning_rate * w1_grad;
    store_field(W1[i * hidden_size + j], Value, data, w1_new_data);
    store_field(W1[i * hidden_size + j], Value, grad, 0.0);
  }
}

for i in range(hidden_size, i64) {
  for j in range(output_size, i64) {
    let w2_grad = load_field(W2[i * output_size + j], Value, grad);
    let w2_data = load_field(W2[i * output_size + j], Value, data);
    let w2_new_data = w2_data - learning_rate * w2_grad;
    store_field(W2[i * output_size + j], Value, data, w2_new_data);
    store_field(W2[i * output_size + j], Value, grad, 0.0);
  }
}

for i in range(hidden_size, i64) {
  let b1_grad = load_field(b1[i], Value, grad);
  let b1_data = load_field(b1[i], Value, data);
  let b1_new_data = b1_data - learning_rate * b1_grad;
  store_field(b1[i], Value, data, b1_new_data);
  store_field(b1[i], Value, grad, 0.0);
}

for i in range(output_size, i64) {
  print(load_field(b2[i], Value, data));
  let b2_grad = load_field(b2[i], Value, grad);
  let b2_data = load_field(b2[i], Value, data);
  let b2_new_data = b2_data - learning_rate * b2_grad;
  store_field(b2[i], Value, data, b2_new_data);
  store_field(b2[i], Value, grad, 0.0);
}